{"version":3,"sources":["../src/commands/hello.ts","../package.json","../src/types/schema.ts","../src/utils/files.ts","../src/utils/isPlaceholder.ts","../src/utils/parseExtras.ts","../src/commands/e.ts","../src/index.ts"],"names":["helloCommand","Command","opts","helloHandler","options","package_default","CommandSchema","z","CommandBodySchema","RegistrySchema","TALOS_FOLDER_NAME","getTalosPath","path","os","getTalosSubfolderPath","subFolder","directoryExists","dirPath","ensureTalosDirectory","askBeforeCreate","talosPath","confirm","subFolderPath","findLocalCommandFile","name","commandsFolder","filePath","raw","parsedCommand","error","e","isPlaceholder","value","parseExtras","extras","knownOptions","flags","unknownTokens","positionals","i","token","next","hasValue","executeCommand","executeHandler","environment","select","findCommand","findLocalCommand","cliOptions","searchCommandSpinner","ora","cliSpinners","resolve","file","selectedVersion","cmd","baseCliArgs","parsed","existingFlags","item","filledArgs","placeholders","arg","defaults","placeholder","label","input","cmdCliArgs","option","primaryOption","commandSpinner","mergedArgs","execa","main","program"],"mappings":"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","file":"index.js","sourcesContent":["import { Command } from \"commander\";\r\n\r\nexport const helloCommand = new Command(\"hello\")\r\n  .description(\"Say hello to the user!\")\r\n  .option(\"-n, --name <name>\", \"Name to greet\", \"World\")\r\n  .action((opts) => helloHandler(opts));\r\n\r\nexport async function helloHandler(options: { name?: string }) {\r\n  console.log(`Hello, ${options.name}`);\r\n}\r\n","{\r\n  \"name\": \"@talos-org/cli\",\r\n  \"version\": \"0.1.18\",\r\n  \"description\": \"\",\r\n  \"publishConfig\": {\r\n    \"access\": \"public\"\r\n  },\r\n  \"license\": \"MIT\",\r\n  \"author\": {\r\n    \"name\": \"sergiocortes-dll\",\r\n    \"url\": \"https://x.com/sergiocortes-dll\"\r\n  },\r\n  \"files\": [\r\n    \"dist\"\r\n  ],\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/Vandlee/talos-cli.git\"\r\n  },\r\n  \"keywords\": [],\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./dist/index.d.ts\",\r\n      \"default\": \"./dist/index.js\"\r\n    }\r\n  },\r\n  \"bin\": {\r\n    \"talos\": \"./dist/index.js\"\r\n  },\r\n  \"scripts\": {\r\n    \"talos\": \"pnpm start:dev\",\r\n    \"dev\": \"tsup --watch\",\r\n    \"build\": \"tsup\",\r\n    \"typecheck\": \"tsc --noEmit\",\r\n    \"start\": \"node dist/index.js\",\r\n    \"start:dev\": \"node dist/index.js\",\r\n    \"pub:beta\": \"pnpm build && pnpm publish --no-git-checks --access public --tag beta\",\r\n    \"pub:next\": \"pnpm build && pnpm publish --no-git-checks --access public --tag next\",\r\n    \"pub:release\": \"pnpm build && pnpm publish --access public\",\r\n    \"test\": \"vitest run\"\r\n  },\r\n  \"packageManager\": \"pnpm@10.28.2\",\r\n  \"dependencies\": {\r\n    \"@inquirer/prompts\": \"^8.2.0\",\r\n    \"chalk\": \"^5.6.2\",\r\n    \"cli-spinners\": \"^3.4.0\",\r\n    \"commander\": \"^14.0.3\",\r\n    \"dotenv\": \"^17.2.4\",\r\n    \"execa\": \"^9.6.1\",\r\n    \"ora\": \"^9.3.0\",\r\n    \"pino\": \"^10.3.0\",\r\n    \"vite-tsconfig-paths\": \"^6.0.5\",\r\n    \"zod\": \"^4.3.6\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/node\": \"^25.2.1\",\r\n    \"eslint\": \"^10.0.0\",\r\n    \"prettier\": \"^3.8.1\",\r\n    \"tsconfig-paths\": \"^4.2.0\",\r\n    \"tsup\": \"^8.5.1\",\r\n    \"tsx\": \"^4.21.0\",\r\n    \"typescript\": \"^5.9.3\",\r\n    \"vitest\": \"^4.0.18\"\r\n  }\r\n}\r\n","import z from \"zod\";\r\n\r\nexport const CommandSchema = z.object({\r\n  name: z.string(),\r\n  options: z.array(z.string()),\r\n  args: z.array(z.string()),\r\n  action: z.string(),\r\n});\r\n\r\nexport const CommandBodySchema = z.object({\r\n  label: z.string().optional(),\r\n  version: z.string(),\r\n  commands: z.array(CommandSchema),\r\n});\r\n\r\nexport const RegistrySchema = z.object({\r\n  name: z.string(),\r\n  body: z.array(CommandBodySchema),\r\n});\r\n\r\nexport type Command = z.infer<typeof CommandSchema>;\r\nexport type CommandBody = z.infer<typeof CommandBodySchema>;\r\nexport type registrySchema = z.infer<typeof RegistrySchema>;\r\n","import { confirm } from \"@inquirer/prompts\";\r\nimport * as fs from \"fs/promises\";\r\nimport os from \"os\";\r\nimport path from \"path\";\r\nimport { z } from \"zod\";\r\nimport { RegistrySchema } from \"../types/schema\";\r\n\r\n// Constants\r\nconst TALOS_FOLDER_NAME = \".talos\";\r\n\r\n/**\r\n * Gets the path to the .talos directory in the user's home folder\r\n */\r\nfunction getTalosPath(): string {\r\n  return path.join(os.homedir(), TALOS_FOLDER_NAME);\r\n}\r\n\r\n/**\r\n * Gets the path to a subfolder within .talos\r\n */\r\nfunction getTalosSubfolderPath(subFolder: string): string {\r\n  return path.join(getTalosPath(), subFolder);\r\n}\r\n\r\n/**\r\n * Checks if a directory exists\r\n */\r\nasync function directoryExists(dirPath: string): Promise<boolean> {\r\n  try {\r\n    await fs.access(dirPath);\r\n    const stats = await fs.stat(dirPath);\r\n    return stats.isDirectory();\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Ensures the .talos directory exists, and optionally a subfolder within it.\r\n * Creates them if they don't exist.\r\n * This function should be called before any local operations.\r\n *\r\n * @param subFolder - Optional subfolder name within .talos (e.g., \"commands\")\r\n * @param askBeforeCreate - If true, asks for confirmation before creating directories\r\n * @returns The path to the .talos directory or subfolder, or null if user declined creation\r\n */\r\nexport async function ensureTalosDirectory(\r\n  subFolder?: string,\r\n  askBeforeCreate = false,\r\n): Promise<string | null> {\r\n  const talosPath = getTalosPath();\r\n\r\n  // Ensure .talos folder exists\r\n  if (!(await directoryExists(talosPath))) {\r\n    if (askBeforeCreate) {\r\n      const shouldCreate = await confirm({\r\n        message: `The .talos directory does not exist in your home folder. Do you want to create it at ${talosPath}?`,\r\n        default: true,\r\n      });\r\n\r\n      if (!shouldCreate) {\r\n        return null;\r\n      }\r\n    }\r\n    await fs.mkdir(talosPath, { recursive: true });\r\n  }\r\n\r\n  // If a subfolder is specified, ensure it exists too\r\n  if (subFolder) {\r\n    const subFolderPath = getTalosSubfolderPath(subFolder);\r\n    if (!(await directoryExists(subFolderPath))) {\r\n      if (askBeforeCreate) {\r\n        const shouldCreate = await confirm({\r\n          message: `The .talos/${subFolder} directory does not exist. Do you want to create it?`,\r\n          default: true,\r\n        });\r\n\r\n        if (!shouldCreate) {\r\n          return null;\r\n        }\r\n      }\r\n      await fs.mkdir(subFolderPath, { recursive: true });\r\n    }\r\n    return subFolderPath;\r\n  }\r\n\r\n  return talosPath;\r\n}\r\n\r\n/**\r\n * @deprecated Use ensureTalosDirectory() instead\r\n */\r\nexport async function ensureTalosFolder() {\r\n  await ensureTalosDirectory();\r\n}\r\n\r\n/**\r\n * Finds and reads a local command file from the .talos/commands directory\r\n *\r\n * @param name - The name of the command (without .json extension)\r\n * @returns The parsed command schema or undefined if not found\r\n * @throws Error with specific message about what went wrong\r\n */\r\nexport async function findLocalCommandFile(\r\n  name: string,\r\n): Promise<z.infer<typeof RegistrySchema> | undefined> {\r\n  const commandsFolder = await ensureTalosDirectory(\"commands\", false);\r\n\r\n  if (!commandsFolder) {\r\n    throw new Error(\"Commands directory is not available\");\r\n  }\r\n\r\n  const filePath = path.join(commandsFolder, `${name}.json`);\r\n\r\n  try {\r\n    await fs.access(filePath);\r\n  } catch {\r\n    return undefined;\r\n  }\r\n\r\n  try {\r\n    const raw = await fs.readFile(filePath, \"utf-8\");\r\n    const parsedCommand = JSON.parse(raw);\r\n    return RegistrySchema.parse(parsedCommand);\r\n  } catch (error) {\r\n    if (error instanceof SyntaxError) {\r\n      throw new Error(\r\n        `Command file \"${name}.json\" contains invalid JSON: ${error.message}`,\r\n      );\r\n    }\r\n    if (error instanceof z.ZodError) {\r\n      throw new Error(\r\n        `Command file \"${name}.json\" has invalid schema: ${error.issues.map((e) => e.message).join(\", \")}`,\r\n      );\r\n    }\r\n    throw new Error(\r\n      `Failed to read command file \"${name}.json\": ${error instanceof Error ? error.message : String(error)}`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the .talos folder exists\r\n *\r\n * @returns true if .talos exists, false otherwise\r\n */\r\nexport async function findTalosFolder(): Promise<boolean> {\r\n  return directoryExists(getTalosPath());\r\n}\r\n\r\n/**\r\n * Finds a specific folder within .talos\r\n *\r\n * @param folderName - The name of the folder to find\r\n * @returns The full path to the folder or undefined if not found\r\n */\r\nexport async function findFolder(\r\n  folderName: string,\r\n): Promise<string | undefined> {\r\n  const folderPath = getTalosSubfolderPath(folderName);\r\n\r\n  if (await directoryExists(folderPath)) {\r\n    return folderPath;\r\n  }\r\n\r\n  return undefined;\r\n}\r\n","export function isPlaceholder(value: string) {\r\n  return /^<[^>]+>$/.test(value) || /^\\[[^\\]]+\\]$/.test(value);\r\n}\r\n","export function parseExtras(extras: string[], knownOptions: Set<string>) {\r\n  const flags: Array<{ flag: string; value: string | null }> = [];\r\n  const unknownTokens: string[] = [];\r\n  const positionals: string[] = [];\r\n\r\n  for (let i = 0; i < extras.length; i += 1) {\r\n    const token = extras[i];\r\n\r\n    if (token.startsWith(\"-\")) {\r\n      const next = extras[i + 1];\r\n      const hasValue = next !== undefined && !next.startsWith(\"-\");\r\n      const value = hasValue ? next : null;\r\n\r\n      if (knownOptions.has(token)) {\r\n        flags.push({ flag: token, value });\r\n      } else {\r\n        unknownTokens.push(token);\r\n        if (hasValue) {\r\n          unknownTokens.push(next);\r\n        }\r\n      }\r\n\r\n      if (hasValue) {\r\n        i += 1;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    positionals.push(token);\r\n  }\r\n\r\n  return { flags, unknownTokens, positionals };\r\n}\r\n","import { input, select } from \"@inquirer/prompts\";\r\nimport cliSpinners from \"cli-spinners\";\r\nimport { Command } from \"commander\";\r\nimport { execa } from \"execa\";\r\nimport ora from \"ora\";\r\nimport { ensureTalosDirectory, findLocalCommandFile } from \"../utils/files\";\r\nimport { isPlaceholder } from \"../utils/isPlaceholder\";\r\nimport { parseExtras } from \"../utils/parseExtras\";\r\n\r\nexport const executeCommand = new Command(\"e\")\r\n  .description(\"Execute a command\")\r\n  .argument(\"<name>\", \"Name of the command\")\r\n  .argument(\"[extras...]\", \"Additional arguments and options\")\r\n  .allowUnknownOption()\r\n  .passThroughOptions()\r\n  .action((name, extras, opts) => executeHandler(name, opts, extras));\r\n\r\nexport async function executeHandler(\r\n  name: string,\r\n  options: any,\r\n  extras?: string[],\r\n) {\r\n  const environment = await select({\r\n    message: \"Where does Talos need to look for the command?\",\r\n    choices: [\r\n      { name: \"Local\", value: \"local\" },\r\n      { name: \"Internet\", value: \"internet\" },\r\n    ],\r\n  });\r\n\r\n  await findCommand(name, environment, { ...options, extras });\r\n}\r\n\r\nasync function findCommand(name: string, environment: string, options: any) {\r\n  if (environment === \"local\") {\r\n    const commandsPath = await ensureTalosDirectory(\"commands\", true);\r\n\r\n    if (!commandsPath) {\r\n      console.error(\r\n        \"\\n❌ Cannot proceed without the .talos/commands directory.\",\r\n      );\r\n      return;\r\n    }\r\n\r\n    await findLocalCommand(name, options);\r\n  }\r\n\r\n  if (environment === \"internet\") {\r\n    console.log(`Looking for ${name} on the internet...`);\r\n    // Implement internet command lookup logic here\r\n  }\r\n}\r\n\r\nasync function findLocalCommand(name: string, cliOptions: any = {}) {\r\n  const searchCommandSpinner = ora({\r\n    text: \"Looking for command locally...\",\r\n    spinner: {\r\n      frames: cliSpinners.circleHalves.frames,\r\n      interval: 80,\r\n    },\r\n  }).start();\r\n\r\n  await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate async operation\r\n\r\n  try {\r\n    const file = await findLocalCommandFile(name);\r\n\r\n    if (!file) {\r\n      searchCommandSpinner.fail(`Command \"${name}\" not found.`);\r\n      return;\r\n    }\r\n\r\n    searchCommandSpinner.succeed(`Command \"${name}\" found locally.`);\r\n\r\n    if (file.body.length <= 0) {\r\n      searchCommandSpinner.fail(\r\n        `Command \"${name}\" exists but has no registered versions.`,\r\n      );\r\n      return;\r\n    }\r\n\r\n    let selectedVersion = file.body[0]; // Default to the first version\r\n\r\n    if (file.body.length > 1) {\r\n      const version = await select({\r\n        message: \"Select a command version to execute:\",\r\n        choices: file.body.map((cmd) => ({\r\n          name: `${cmd.version}${cmd.label ? ` - ${cmd.label}` : \"\"}`,\r\n          value: cmd,\r\n        })),\r\n      });\r\n\r\n      selectedVersion = version || selectedVersion;\r\n    }\r\n\r\n    // Build CLI args from extras while prompting for missing values defined in the registry.\r\n    const baseCliArgs: string[] = [];\r\n    const extras = Array.isArray(cliOptions.extras) ? cliOptions.extras : [];\r\n\r\n    const knownOptions = new Set(\r\n      selectedVersion.commands.flatMap((cmd) => cmd.options),\r\n    );\r\n    const parsed = parseExtras(extras, knownOptions);\r\n\r\n    // Preserve provided flags, unknown flags, and positional args as-is.\r\n    const existingFlags = new Set(parsed.flags.map((item) => item.flag));\r\n    for (const item of parsed.flags) {\r\n      baseCliArgs.push(item.flag);\r\n      if (item.value !== null) {\r\n        baseCliArgs.push(item.value);\r\n      }\r\n    }\r\n    baseCliArgs.push(...parsed.unknownTokens);\r\n    baseCliArgs.push(...parsed.positionals);\r\n\r\n    for (const cmd of selectedVersion.commands) {\r\n      // Prompt for missing positional args (placeholders like <host> or [host]).\r\n      const filledArgs: string[] = [];\r\n      const placeholders = cmd.args.filter((arg) => isPlaceholder(arg));\r\n      const defaults = cmd.args.filter((arg) => !isPlaceholder(arg));\r\n\r\n      for (const placeholder of placeholders) {\r\n        const label = placeholder.replace(/[\\[\\]<>]/g, \"\").trim() || \"value\";\r\n        const value = await input({\r\n          message: `What argument are you gonna send? (${label})`,\r\n        });\r\n        filledArgs.push(value);\r\n      }\r\n\r\n      filledArgs.unshift(...defaults);\r\n\r\n      // Prompt for known options that are missing in the CLI.\r\n      const cmdCliArgs = [...baseCliArgs];\r\n\r\n      if (cmd.options.length > 0) {\r\n        const hasProvided = cmd.options.some((option) =>\r\n          existingFlags.has(option),\r\n        );\r\n        if (!hasProvided) {\r\n          const primaryOption = cmd.options[0];\r\n          const value = await input({\r\n            message: `What do you want to use for \"${primaryOption}\" argument?`,\r\n            default: \"\",\r\n          });\r\n\r\n          if (value !== \"\") {\r\n            cmdCliArgs.push(primaryOption, value);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const cmd of selectedVersion.commands) {\r\n        const commandSpinner = ora({\r\n          text: `Executing command: ${cmd.name}...`,\r\n          spinner: {\r\n            frames: cliSpinners.circleHalves.frames,\r\n            interval: 80,\r\n          },\r\n        }).start();\r\n\r\n        try {\r\n          commandSpinner.stop();\r\n\r\n          // Merge JSON args with CLI args\r\n          const mergedArgs = [...filledArgs, ...cmdCliArgs];\r\n\r\n          console.log(`\\n$ ${cmd.action} ${mergedArgs.join(\" \")}\\n`);\r\n\r\n          await execa(cmd.action, mergedArgs, { stdio: \"inherit\" });\r\n\r\n          console.log();\r\n          commandSpinner.succeed(`Executed command: ${cmd.name}`);\r\n        } catch (error) {\r\n          commandSpinner.fail(`Failed to execute command: ${cmd.name}`);\r\n          if (error instanceof Error) {\r\n            console.error(`Error: ${error.message}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    searchCommandSpinner.fail(\"Failed to load command\");\r\n    if (error instanceof Error) {\r\n      console.error(`\\n❌ ${error.message}\\n`);\r\n    } else {\r\n      console.error(`\\n❌ An unexpected error occurred: ${String(error)}\\n`);\r\n    }\r\n  }\r\n}\r\n","#!/usr/bin/env node\r\n\r\nimport { Command } from \"commander\";\r\nimport { helloCommand } from \"./commands/hello\";\r\n\r\nimport packageJson from \"../package.json\";\r\nimport { executeCommand } from \"./commands/e\";\r\n\r\nprocess.on(\"SIGINT\", () => process.exit(0));\r\nprocess.on(\"SIGTERM\", () => process.exit(0));\r\n\r\nasync function main() {\r\n  const program = new Command()\r\n    .name(\"talos\")\r\n    .description(\"Manage everything.\")\r\n    .version(\r\n      packageJson.version || \"1.0.0\",\r\n      \"-v, --version\",\r\n      \"display the version number\",\r\n    )\r\n    .enablePositionalOptions();\r\n\r\n  program.addCommand(helloCommand);\r\n  program.addCommand(executeCommand);\r\n\r\n  program.parse();\r\n}\r\n\r\nmain();\r\n"]}